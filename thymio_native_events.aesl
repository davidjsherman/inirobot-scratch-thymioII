<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="8" name="thymioII_leds_prox_h"/>
<event size="8" name="thymioII_leds_circle"/>
<event size="3" name="thymioII_leds_top"/>
<event size="4" name="thymioII_leds_bottom"/>
<event size="2" name="thymioII_leds_prox_v"/>
<event size="4" name="thymioII_leds_buttons"/>
<event size="1" name="thymioII_leds_rc"/>
<event size="2" name="thymioII_leds_temperature"/>
<event size="1" name="thymioII_leds_sound"/>
<event size="2" name="thymioII_sound_freq"/>
<event size="1" name="thymioII_sound_play"/>
<event size="1" name="thymioII_sound_system"/>
<event size="1" name="thymioII_sound_replay"/>
<event size="32" name="thymioII_sound_wave"/>
<event size="1" name="thymioII_sound_record"/>
<event size="1" name="thymioII_left_motor"/>
<event size="1" name="thymioII_right_motor"/>
<event size="1" name="scratch_set_dial"/>
<event size="0" name="scratch_next_dial"/>
<event size="1" name="scratch_next_dial_limit"/>
<event size="4" name="Q_enqueue"/>
<event size="1" name="scratch_move"/>
<event size="1" name="scratch_turn"/>
<event size="2" name="scratch_arc"/>
<event size="2" name="scratch_start"/>
<event size="0" name="scratch_stop"/>
<event size="2" name="scratch_change_speed"/>
<event size="0" name="scratch_clear_leds"/>
<event size="2" name="scratch_set_leds"/>
<event size="2" name="scratch_change_leds"/>
<event size="0" name="scratch_avoid"/>


<!--list of constants-->
<constant value="8" name="QUEUE"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">### Scratch personality for Thymio-II
### David J Sherman - david.sherman@inria.fr
### 
### 1. Local state: dial spinner, motion queue
### 2. Motion update at 16Hz triggered by acc
### 3. Provide high-level Scratch events scratch_*
### 4. Expose native functions as sevent thymioII_*


### Variables for additional local state
## spinning dial 
var scratch_dial = 1
var scr_tmp[9] # reusable temp for event handlers
var avd[3] = [0,0,0]

## simple queue for motion commands
var QtpL[QUEUE] = [ 0,0,0,0,0,0,0,0 ] # target dist L
var QtpR[QUEUE] = [ 0,0,0,0,0,0,0,0 ] # target dist R
var QdL[QUEUE]  = [ 0,0,0,0,0,0,0,0 ] # motor speed L
var QdR[QUEUE]  = [ 0,0,0,0,0,0,0,0 ] # motor speed R
var Qpc = 0                           # program counter
var Qnx = 1                           # next queue position
var Qwait = 1                         # delay between changes

## Scratch-friendly reporters, updated at 10 Hz from button event
var distance.front
var distance.back
var distance.ground
var b_button.backward
var b_button.left
var b_button.center
var b_button.forward
var b_button.right
var b_clap
var b_touching.front
var b_touching.back
var b_touching.ground
var proximity.front
var proximity.back
var proximity.ground
var near_side
var motorspeed.left
var motorspeed.right
var tilt.right.left
var tilt.front.back
var tilt.top.bottom
var leds.colors[3] = [0,0,0]

mic.threshold = 14

### Motion update
## Every 16 Hz tick from acc event: if queue is active,
## check progress towards current left- and right-motor motion goals

onevent acc # loop runs at 16 Hz
if	Qpc >= 0 and Qwait == 0 then
	if	(QtpL[Qpc] != 0 or QtpR[Qpc] != 0) then
		# progress towards goal
		QtpL[Qpc] -= motor.left.speed # use measured speed
		if	abs(QtpL[Qpc]) >= abs(QdL[Qpc]) then
			motor.left.target = QdL[Qpc]
		else
			motor.left.target = 0
			QtpL[Qpc] = 0
			#Qwait = 2 # allow 1/8 sec for deceleration
		end
		QtpR[Qpc] -= motor.right.speed # use measured speed
		if 	abs(QtpR[Qpc]) >= abs(QdR[Qpc]) then
			motor.right.target = QdR[Qpc]
		else
			motor.right.target = 0
			QtpR[Qpc] = 0
			#Qwait = 2 # allow 1/8 sec for deceleration
		end
	else
		# scan forward in the queue
		Qpc = (Qpc+1)%QUEUE
	end
elseif	Qwait > 0 then
	Qwait -= 1
end

## Add new goal to the queue at position Qnx

sub Q_enqueue
QtpL[Qnx] = scr_tmp[0]
QtpR[Qnx] = scr_tmp[1]
QdL[Qnx]  = scr_tmp[2]
QdR[Qnx]  = scr_tmp[3]
Qnx = (Qnx+1)%QUEUE
if  Qpc &lt; 0 then
	Qpc = Qnx
end

onevent Q_enqueue
scr_tmp[0:3] = event.args[0:3] 
callsub Q_enqueue


### Reporter update
## Every 10 Hz tick from button event: update variables used by extension
## definition. Asebahttp treats variable names starting with b_ as boolean

onevent buttons
b_button.backward = button.backward
b_button.left = button.left
b_button.center = button.center
b_button.forward = button.forward
b_button.right = button.right
# booleans for touching
call math.dot(b_touching.front,prox.horizontal,[1,1,1,1,1,0,0],10)
if  b_touching.front > 0 then
	b_touching.front = 1
end
call math.dot(b_touching.back,prox.horizontal,[0,0,0,0,0,1,1],10)
if  b_touching.back > 0 then
	b_touching.back = 1
end
call math.dot(b_touching.ground,prox.ground.delta,[1,1],9)
if  b_touching.ground > 0 then
	b_touching.ground = 1
end
# code sensors value vectors in single integers
call math.div(scr_tmp[0:6],prox.horizontal,[1533,1533,1533,1533,1533,1150,1150])
proximity.front = 10000*scr_tmp[0] + 1000*scr_tmp[1] + 100*scr_tmp[2] + 10*scr_tmp[3] + scr_tmp[4]
proximity.back = 10*scr_tmp[5] + scr_tmp[6]
proximity.ground = 10*(prox.ground.delta[0]/250) + prox.ground.delta[1]/250
# distance in front (approx mm)
call math.dot(distance.front, prox.horizontal,[13,26,39,26,13,0,0],11)
# older firmware doesn't have math.clamp
distance.front = 190-distance.front
if distance.front &lt; 0 then
	distance.front = 0
elseif distance.front > 190 then
	distance.front = 190
end
# distance in back (approx mm)
call math.max(distance.back, prox.horizontal[5],prox.horizontal[6])
call math.muldiv(distance.back, distance.back, 267,10000)
# older firmware doesn't have math.clamp
distance.back = 125-distance.front
if distance.back &lt; 0 then
	distance.back = 0
elseif distance.back > 125 then
	distance.back = 125
end
# near side (approx degrees)
call math.dot(near_side, prox.horizontal,[4,3,0,-3,-4,0,0],9)
# syntactic sugar for motor speed, tilt
motorspeed.left = motor.left.speed
motorspeed.right = motor.right.speed
tilt.right.left = acc[0]
tilt.front.back = acc[1]
tilt.top.bottom = acc[2]
# b_clap if mic intensity over threshold
if mic.intensity >= mic.threshold then
	b_clap = 1
else
	b_clap = 0
end


### Scratch events
## scratch_move/:mm
onevent scratch_move
scr_tmp[0] = event.args[0] * 50
# older firmware doesn't have math.clamp
scr_tmp[2] = abs(event.args[0])
if scr_tmp[2] &lt; 20 then
	scr_tmp[2] = 20
elseif scr_tmp[2] > 150 then
	scr_tmp[2] = 150
end
if event.args[0] &lt; 0 then
	call math.muldiv(scr_tmp[2],-scr_tmp[2],32,10)
else
	call math.muldiv(scr_tmp[2],scr_tmp[2],32,10)
end
scr_tmp[0:3] = [ scr_tmp[0],scr_tmp[0], scr_tmp[2],scr_tmp[2] ]
callsub Q_enqueue

## scratch_turn/:degrees
onevent scratch_turn
scr_tmp[0] = abs(event.args[0])
# dist = 39.76 * degrees + 1.225 * speed - 96.57
if	scr_tmp[0]>90 then
	scr_tmp[2] = 207
	call math.muldiv(scr_tmp[0], scr_tmp[0], 3976, 100)
	scr_tmp[0] += 157
else
	scr_tmp[2] = 138
	call math.muldiv(scr_tmp[0], scr_tmp[0], 3976, 100)
	scr_tmp[0] += 73
end
if  event.args[0] &lt; 0 then
	scr_tmp[0:3] = [ -scr_tmp[0],scr_tmp[0], -scr_tmp[2],scr_tmp[2] ]
else
	scr_tmp[0:3] = [ scr_tmp[0],-scr_tmp[0], scr_tmp[2],-scr_tmp[2] ]
end
callsub Q_enqueue

## scratch_arc/:radius/:degrees
onevent scratch_arc
# ratio
call math.muldiv(scr_tmp[7], 10000, abs(event.args[0])-95, abs(event.args[0]))
# scr_tmp[0] is distance to travel
scr_tmp[4] = abs(event.args[1]) # degrees; pi/180 ~ 35/2000
call math.muldiv(scr_tmp[4], scr_tmp[4]*35, abs(event.args[0]), 2000) 
call math.muldiv(scr_tmp[5], scr_tmp[4], scr_tmp[7], 10000)
# scr_tmp[3] is speed &lt;= 500
call math.muldiv(scr_tmp[6], 400, scr_tmp[7], 10000)
#
call math.muldiv(scr_tmp[8], abs(event.args[1]),abs(event.args[0]), 10)
if scr_tmp[8] &lt; 3714 then
	scr_tmp[7] = 1
	scr_tmp[4] *= 50
	scr_tmp[5] *= 50
else
	scr_tmp[7] = 5
	scr_tmp[4] *= 10
	scr_tmp[5] *= 10
end
while scr_tmp[7] > 0 do
	if  event.args[1] &lt; 0 then
		scr_tmp[0:3] = [ scr_tmp[5],scr_tmp[4], scr_tmp[6],400 ]
	else
		scr_tmp[0:3] = [ scr_tmp[4],scr_tmp[5], 400,scr_tmp[6] ]
	end
	if  event.args[0] &lt; 0 then
		scr_tmp[0:3] = [ -scr_tmp[0], -scr_tmp[1], -scr_tmp[2], -scr_tmp[3] ]
	end
	callsub Q_enqueue
	scr_tmp[7] -= 1
end

## scratch_start/:left/:right
onevent scratch_start
call math.muldiv(scr_tmp[0], event.args[0], 32, 10)
call math.muldiv(scr_tmp[1], event.args[1], 32, 10)
motor.left.target = scr_tmp[0]
motor.right.target = scr_tmp[1]

## scratch_stop
onevent scratch_stop
motor.left.target = 0
motor.right.target = 0

## scratch_change_speed/:left/:right
onevent scratch_change_speed
call math.muldiv(scr_tmp[0], event.args[0], 32, 10)
call math.muldiv(scr_tmp[1], event.args[1], 32, 10)
motor.left.target += scr_tmp[0]
motor.right.target += scr_tmp[1]

## scratch_avoid
onevent scratch_avoid
call math.muldiv(scr_tmp[0], -1520 + 12*distance.front + 400*near_side, motor.left.target,  760)
call math.muldiv(scr_tmp[1], -1520 + 12*distance.front - 400*near_side, motor.right.target, 760)
if abs(scr_tmp[0]-scr_tmp[1]) &lt; 20 then
	call math.rand(scr_tmp[7])
	scr_tmp[0] += scr_tmp[7] / 2048
end
avd[0:2] = [motor.left.target, motor.right.target, 3]
motor.left.target = scr_tmp[0]
motor.right.target = scr_tmp[1]
timer.period[1] = 30

onevent timer1
if avd[2] > 0 then
	if avd[0]>5 or avd[1]>5 then
		motor.left.target = avd[0]
		motor.right.target = avd[1]
	end
	timer.period[1] = 30
	avd[2] -= 1
else
	avd[0:2] = [0,0,0]
end

## scratch_set_leds
sub _scratch_set_leds
scr_tmp[0] %= 198
scr_tmp[5] = scr_tmp[0] / 33
if scr_tmp[5]==0 then
	scr_tmp[2:4] = [33, scr_tmp[0]%33, 0]
elseif scr_tmp[5]==1 then
	scr_tmp[2:4] = [33-(scr_tmp[0]%33), 33, 0 ]
elseif scr_tmp[5]==2 then
	scr_tmp[2:4] = [0, 33, scr_tmp[0]%33]
elseif scr_tmp[5]==3 then
	scr_tmp[2:4] = [0, 33-scr_tmp[0]%33, 33]
elseif scr_tmp[5]==4 then
	scr_tmp[2:4] = [scr_tmp[0]%33, 0, 33]
elseif scr_tmp[5]==5 then
	scr_tmp[2:4] = [33, 0, 33-scr_tmp[0]%33]
end
if scr_tmp[1] &amp; 1 == 1 then
	call leds.top(scr_tmp[2],scr_tmp[3],scr_tmp[4])
	leds.colors[0] = scr_tmp[0]
end
if scr_tmp[1] &amp; 2 == 2 then
	call leds.bottom.left(scr_tmp[2],scr_tmp[3],scr_tmp[4])
	leds.colors[1] = scr_tmp[0]
end
if scr_tmp[1] &amp; 4 == 4 then
	call leds.bottom.right(scr_tmp[2],scr_tmp[3],scr_tmp[4])
	leds.colors[2] = scr_tmp[0]
end

## scratch_set_leds
onevent scratch_set_leds
scr_tmp[0:1] = [event.args[0] % 198, event.args[1]]
callsub _scratch_set_leds

## scratch_change_leds
onevent scratch_change_leds
scr_tmp[6:7] = [event.args[0] % 198, event.args[1]]
scr_tmp[0:1] = [leds.colors[0] + scr_tmp[6] * (scr_tmp[7] &amp; 1), (scr_tmp[7] &amp; 1)]
callsub _scratch_set_leds
scr_tmp[0:1] = [leds.colors[1] + scr_tmp[6] * (scr_tmp[7] &amp; 2)/2, (scr_tmp[7] &amp; 2)]
callsub _scratch_set_leds
scr_tmp[0:1] = [leds.colors[2] + scr_tmp[6] * (scr_tmp[7] &amp; 4)/4, (scr_tmp[7] &amp; 4)]
callsub _scratch_set_leds

## scratch_clear_leds
onevent scratch_clear_leds
call leds.circle(0,0,0,0,0,0,0,0)
call leds.top(0,0,0)
call leds.bottom.right(0,0,0)
call leds.bottom.left(0,0,0)
leds.colors = [0,0,0]

## costume is a clock dial using the circle LEDs
sub _scratch_dial_set_leds
scr_tmp[0:7] = [0,0,0,0,0,0,0,0]
scr_tmp[(scratch_dial % 8)] = 8
if (scratch_dial / 8) % 9 > 0 then
	scr_tmp[((scratch_dial / 8) % 9) - 1] = 24
end
if (scratch_dial / 72) % 9 > 0 then
	scr_tmp[((scratch_dial / 72) % 9) - 1] = 32
end
call leds.circle(scr_tmp[0],scr_tmp[1],scr_tmp[2],scr_tmp[3],scr_tmp[4],scr_tmp[5],scr_tmp[6],scr_tmp[7])

## scratch_set_dial
onevent scratch_set_dial
scratch_dial = event.args[0]
callsub _scratch_dial_set_leds

## scratch_next_dial
onevent scratch_next_dial
scratch_dial = (scratch_dial + 1) % 8
callsub _scratch_dial_set_leds

## scratch_next_dial_limit
onevent scratch_next_dial_limit # up to 648 = 9 * 9 * 8
scratch_dial = (scratch_dial + 1) % event.args[0]
callsub _scratch_dial_set_leds


### Events to expose Aseba native functions as events

## Event handlers for native functions
onevent thymioII_leds_bottom #
if event.args[0]==0 then
	call leds.bottom.left(event.args[1],event.args[2],event.args[3])
else
	call leds.bottom.right(event.args[1],event.args[2],event.args[3])
end

onevent thymioII_leds_buttons #
call leds.buttons(event.args[0],event.args[1],
                  event.args[2],event.args[3])

onevent thymioII_leds_circle #
call leds.circle(event.args[0],event.args[1],event.args[2],
	             event.args[3],event.args[4],event.args[5],
	             event.args[6],event.args[7])

onevent thymioII_leds_prox_h #
call leds.prox.h(event.args[0],event.args[1],event.args[2],
	             event.args[3],event.args[4],event.args[5],
	             event.args[6],event.args[7])

onevent thymioII_leds_prox_v #
call leds.prox.v(event.args[0],event.args[1])

onevent thymioII_leds_rc #
call leds.rc(event.args[0])

onevent thymioII_leds_sound #
call leds.sound(event.args[0])

onevent thymioII_leds_temperature #
call leds.temperature(event.args[0],event.args[1])

onevent thymioII_leds_top #
call leds.top(event.args[0],event.args[1],event.args[2])

onevent thymioII_sound_freq #
call sound.freq(event.args[0],event.args[1])

onevent thymioII_sound_play #
call sound.play(event.args[0])

onevent thymioII_sound_record #
call sound.record(event.args[0])

onevent thymioII_sound_replay #
call sound.replay(event.args[0])

onevent thymioII_sound_system #
call sound.system(event.args[0])

onevent thymioII_sound_wave #
#for scr_tmp[0] in 0:141 do
#	thymioII_wave[scr_tmp[0]] = event.args[scr_tmp[0] % 32]
#end
#call sound.wave(thymioII_wave)

onevent thymioII_left_motor
motor.left.target = event.args[0] * 32 / 10

onevent thymioII_right_motor
motor.right.target = event.args[0] * 32 / 10</node>


</network>
